/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <string.h> /* for memset */
#include <VoiceRPC_System.h>
#include <rpc_client.h>

#include <RPCBaseDS.h>
#include <VoiceRPCBaseDS.h>

VOICE_RPCRES_INIT *
VOICE_RPC_ToAgent_Init_0(VOICE_RPC_INIT *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	VOICE_RPCRES_INIT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_INIT);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (VOICE_RPCRES_INIT *) rpc_malloc(sizeof(VOICE_RPCRES_INIT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_Init, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_INIT, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (VOICE_RPCRES_INIT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(VOICE_RPCRES_INIT), XDR_DECODE);
		if (!xdr_VOICE_RPCRES_INIT(&xdrs, result)) {
			return (VOICE_RPCRES_INIT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
VOICE_RPC_ToAgent_Release_0(VOICE_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_Release, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
VOICE_RPC_ToAgent_Streaming_Process_0(VOICE_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_Streaming_Process, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
VOICE_RPC_ToAgent_Recognizer_Process_0(VOICE_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_Recognizer_Process, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
VOICE_RPC_ToAgent_Sync_Mic_Data_0(VOICE_RPC_MIC_DATA *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_MIC_DATA);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_Sync_Mic_Data, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_MIC_DATA, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
VOICE_RPC_ToAgent_USR_CMD_0(VOICE_RPC_USR_CMD *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(VOICE_RPC_USR_CMD);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, VOICE_RPC_ToAgent_USR_CMD, clnt->send_mode,
					   (xdrproc_t) xdr_VOICE_RPC_USR_CMD, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}
