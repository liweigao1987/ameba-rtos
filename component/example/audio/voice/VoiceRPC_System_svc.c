/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <VoiceRPC_System.h>
#include <string.h>
#include <rpc_server.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <RPCBaseDS.h>
#include <VoiceRPCBaseDS.h>

static void
VOICE_SYSTEM_0(RPC_STRUCT *rpc, int32_t opt, RPC_Mutex *pMutex, char *buf)
{
	union {
		VOICE_RPC_INIT VOICE_RPC_ToAgent_Init_0_arg;
		VOICE_RPC_INSTANCE VOICE_RPC_ToAgent_Release_0_arg;
		VOICE_RPC_INSTANCE VOICE_RPC_ToAgent_Streaming_Process_0_arg;
		VOICE_RPC_INSTANCE VOICE_RPC_ToAgent_Recognizer_Process_0_arg;
		VOICE_RPC_MIC_DATA VOICE_RPC_ToAgent_Sync_Mic_Data_0_arg;
		VOICE_RPC_USR_CMD VOICE_RPC_ToAgent_USR_CMD_0_arg;
	} argument;

	union {
		VOICE_RPCRES_INIT VOICE_RPC_ToAgent_Init_0_ret;
		HRESULT VOICE_RPC_ToAgent_Release_0_ret;
		HRESULT VOICE_RPC_ToAgent_Streaming_Process_0_ret;
		HRESULT VOICE_RPC_ToAgent_Recognizer_Process_0_ret;
		HRESULT VOICE_RPC_ToAgent_Sync_Mic_Data_0_ret;
		HRESULT VOICE_RPC_ToAgent_USR_CMD_0_ret;
	} retval;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct RPC_STRUCT *, char *);
	int ReplyParaSize;


	switch (rpc->procedure_id) {
	case VOICE_RPC_ToAgent_Init:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_INIT;
		_xdr_result = (xdrproc_t) xdr_VOICE_RPCRES_INIT;
		ReplyParaSize = sizeof(VOICE_RPCRES_INIT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_Init_0_svc;
		break;

	case VOICE_RPC_ToAgent_Release:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_INSTANCE;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_Release_0_svc;
		break;

	case VOICE_RPC_ToAgent_Streaming_Process:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_INSTANCE;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_Streaming_Process_0_svc;
		break;

	case VOICE_RPC_ToAgent_Recognizer_Process:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_INSTANCE;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_Recognizer_Process_0_svc;
		break;

	case VOICE_RPC_ToAgent_Sync_Mic_Data:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_MIC_DATA;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_Sync_Mic_Data_0_svc;
		break;

	case VOICE_RPC_ToAgent_USR_CMD:
		_xdr_argument = (xdrproc_t) xdr_VOICE_RPC_USR_CMD;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) VOICE_RPC_ToAgent_USR_CMD_0_svc;
		break;

	default:
		return;
	}


	memset((char *)&argument, 0, sizeof(argument));


	if (!RPC_GetArgs(rpc, (xdrproc_t) _xdr_argument, (caddr_t) &argument, opt, buf)) {
		printf("get args error\n");
		RPC_MutexUnlock(pMutex);
		return;
	}

	RPC_MutexUnlock(pMutex);

	(*local)((char *)&argument, rpc, (char *)&retval);


	// When source msg is BLOCK_MODE,
	// we must help it reply
	// ps: reply mode is NON_BLOCK and use request's ringbuf type
	if (rpc->task_id != 0) {
		RPC_SendReply(rpc->task_id, rpc->context, (char *)&retval, ReplyParaSize,
					  (xdrproc_t) _xdr_result, opt);
	}

	return;
}
VOICE_RPCRES_INIT   *(*p_VOICE_RPC_ToAgent_Init_0_svc)(VOICE_RPC_INIT *pParam, RPC_STRUCT *pRpcStruct, VOICE_RPCRES_INIT *pRes) = 0;

VOICE_RPCRES_INIT *VOICE_RPC_ToAgent_Init_0_svc(VOICE_RPC_INIT *pParam, RPC_STRUCT *pRpcStruct, VOICE_RPCRES_INIT *pRes)
{
	if (p_VOICE_RPC_ToAgent_Init_0_svc) {
		p_VOICE_RPC_ToAgent_Init_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_VOICE_RPC_ToAgent_Release_0_svc)(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *VOICE_RPC_ToAgent_Release_0_svc(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_VOICE_RPC_ToAgent_Release_0_svc) {
		p_VOICE_RPC_ToAgent_Release_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_VOICE_RPC_ToAgent_Streaming_Process_0_svc)(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *VOICE_RPC_ToAgent_Streaming_Process_0_svc(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_VOICE_RPC_ToAgent_Streaming_Process_0_svc) {
		p_VOICE_RPC_ToAgent_Streaming_Process_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_VOICE_RPC_ToAgent_Recognizer_Process_0_svc)(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *VOICE_RPC_ToAgent_Recognizer_Process_0_svc(VOICE_RPC_INSTANCE *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_VOICE_RPC_ToAgent_Recognizer_Process_0_svc) {
		p_VOICE_RPC_ToAgent_Recognizer_Process_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_VOICE_RPC_ToAgent_Sync_Mic_Data_0_svc)(VOICE_RPC_MIC_DATA *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *VOICE_RPC_ToAgent_Sync_Mic_Data_0_svc(VOICE_RPC_MIC_DATA *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_VOICE_RPC_ToAgent_Sync_Mic_Data_0_svc) {
		p_VOICE_RPC_ToAgent_Sync_Mic_Data_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_VOICE_RPC_ToAgent_USR_CMD_0_svc)(VOICE_RPC_USR_CMD *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *VOICE_RPC_ToAgent_USR_CMD_0_svc(VOICE_RPC_USR_CMD *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_VOICE_RPC_ToAgent_USR_CMD_0_svc) {
		p_VOICE_RPC_ToAgent_USR_CMD_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}



struct REG_STRUCT *VOICE_SYSTEM_0_register(struct REG_STRUCT *rnode)
{

	REG_STRUCT *pReg = (struct REG_STRUCT *)RPC_Register(rnode, VOICE_SYSTEM, 0,
					   (void (*)(struct RPC_STRUCT *, int32_t, RPC_Mutex *, char *))VOICE_SYSTEM_0);
	return pReg;
}
